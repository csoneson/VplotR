#' A bamutils function to import a single .bam file
#'
#' \code{read.bam(file)} returns the reads contained in the .bam file in a 
#'   GRanges object. Tested .bam files have been generated by BWA and follow
#'   the standard BAM format.
#'
#' @param file A character vector. Each element is the path of an individual
#'   .bam file.
#' @param remove.duplicates A boolean value. Should the duplicate reads 
#'   (mapping to the same coordinates) be removed? 
#' @param paired.reads A boolean value. Are the reads paired-end?
#' @param filter.lengths A numeric vector of length 2. The two values indicate
#'   the minimum / maximum size of the reads to be returned.
#' @param quality.cutoff An integer. The minimum mapping quality of the reads
#'   to be returned. 
#' @return A GRanges object containing reads from the .bam file. 
#' @examples
#' read.bam(file, remove.duplicates = T, paired.reads = F filter.lengths = 
#'   c(50, 250))
#' 

importBam <- function(
    
    files, 
    remove.duplicates = T, 
    paired.reads = F, 
    filter.lengths = c(0, 0), 
    quality.cutoff = 10L
    
    ){
    
    # Check that all the files exist
    stopifnot(all(file.exists(files)))
    
    list.bam <- parallel::mclapply(files, function(FILE) {
        
        # Import bam file as list using the fast scanBam function
        message('>>> Import bam file: ', FILE)
        what <- c("rname", "strand", "pos", "qwidth", "mapq", "flag", "mpos", "isize")
        a <- Rsamtools::scanBam(FILE, param = Rsamtools::ScanBamParam(what = what), asMates = T)[[1]]
        
        # Subset valid reads
        aligned <- !is.na(a$pos)
        paired <- !is.na(a$mpos) & !is.na(a$pos - a$mpos > 0) & (a$pos - a$mpos) != 0 & abs(a$isize) > 0
        qual.cutoff <- a$mapq >= quality.cutoff & !(is.na(a$mapq))
        
        # Create GRanges object
        if (paired.reads) {
            subset <- aligned & paired & qual.cutoff
            frag.granges <- GenomicRanges::GRanges(
                seqnames = a$rname[subset],
                ranges = IRanges::IRanges(start = ifelse(a$pos[subset] < a$mpos[subset], a$pos[subset], a$mpos[subset]), width = abs(a$isize[subset])),
                strand = a$strand[subset]
            )
        } else {
            subset <- aligned & qual.cutoff
            frag.granges <- GenomicRanges::GRanges(
                seqnames = a$rname[subset],
                ranges = IRanges::IRanges(start = a$pos[subset], width = a$qwidth[subset]),
                strand = a$strand[subset]
            )
        }
        
        # Additional filters
        if (remove.duplicates) { frag.granges <- frag.granges[!duplicated(frag.granges)] }
        if (filter.lengths[1] > 0) { frag.granges <- frag.granges[IRanges::width(frag.granges) >= filter.lengths[1]] }
        if (filter.lengths[2] > 0) { frag.granges <- frag.granges[IRanges::width(frag.granges) <= filter.lengths[2]] }
        
        # Add name of file as attribute
        attr(frag.granges, 'names') <- basename(FILE) %>% gsub('.bam$', '', .)
        
        # Return filtered reads/fragments as a GRanges
        return(frag.granges)
            
    }, mc.cores = length(files))
    
    if (length(files) == 1)
        list.bam <- list.bam[[1]]
    
    return(list.bam)
    
}

