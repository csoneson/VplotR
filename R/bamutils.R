#' A function to import paired end bam files as GRanges
#'
#' \code{read.bam(file)} returns the reads contained in the .bam file in a 
#'   GRanges object. Tested .bam files have been generated by BWA and follow
#'   the standard BAM format.
#'
#' @param file A character vector. Each element is the path of an individual
#'   .bam file.
#' @param remove.duplicates A boolean value. Should the duplicate reads 
#'   (mapping to the same coordinates) be removed? 
#' @param paired.reads A boolean value. Are the reads paired-end?
#' @param filter.lengths A numeric vector of length 2. The two values indicate
#'   the minimum / maximum size of the reads to be returned.
#' @param quality.cutoff An integer. The minimum mapping quality of the reads
#'   to be returned. 
#' @return A GRanges object containing reads from the .bam file. 
#' @examples
#' read.bam(file, remove.duplicates = T, paired.reads = F filter.lengths = 
#'   c(50, 250))
#' 

importPEBamFiles <- function(
    files, 
    where = NULL, 
    max_insert_size = 1000, 
    shift_ATAC_fragments = FALSE, 
    verbose = TRUE
)
{
    list.bam <- parallel::mclapply(files, function(FILE) {
        if (!file.exists(paste0(FILE, '.bai'))) stop('
            Bam index not found. Please create one with samtools index. Aborting.'
        )
        bam <- Rsamtools::BamFile(FILE, yieldSize = 50000000, asMates = TRUE)
        if (is.null(where)) {
            where <- Rsamtools::scanBamHeader(bam, what = c("targets"))$targets
            where <- GenomicRanges::GRanges(seqnames = names(where), IRanges::IRanges(1, where))
        } else {
            where <- GenomicRanges::reduce(IRanges::resize(where, width = IRanges::width(where) + 1000, fix = 'center'))
        }
        params <- Rsamtools::ScanBamParam(
            which = where, 
            what = c("qname", "mapq", "isize", "flag"), 
            flag = Rsamtools::scanBamFlag(
                isPaired = TRUE, 
                isProperPair = TRUE, 
                isSecondaryAlignment = FALSE,
                isUnmappedQuery = FALSE,
                isNotPassingQualityControls = FALSE,
                isSupplementaryAlignment = FALSE
            )
        )
        if (verbose) message('> Importing ', FILE, ' ...')
        a <- GenomicAlignments::readGAlignmentPairs(bam, param = params)
        if (verbose) message('> Filtering ', FILE, ' ...')
        g <- GenomicAlignments::granges(a)
        # Filter by insert size
        if (max_insert_size > 0 & !is.null(max_insert_size)) g <- g[IRanges::width(g) <= max_insert_size]
        # Shift ATAC fragments
        if (shift_ATAC_fragments) {
            if (verbose) message('> Shifting ', FILE, ' ...')
            g <- shiftATACGranges(g)
        }
        # Return GRanges
        if (verbose) message('> ', FILE, ' import completed.')
        return(g)
    }, mc.cores = length(files))
    if (length(files) == 1) list.bam <- list.bam[[1]]
    return(list.bam)
}

shiftATACGranges <- function(g) {
    if (any(GenomicRanges::strand(g) == '*')) stop(
        'Error: the input GRanges has some unstranded fragments. 
        Please read ban files using importPEBamFiles with shift_ATAC_fragments = TRUE.'
    )
    IRanges::shift(g, ifelse(GenomicRanges::strand(g) == '+', 5, 4))
}